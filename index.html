<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GalaxyTon Floppy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0; padding: 0; width: 100vw; height: 100vh; background: #191726;
      overflow: hidden;
    }
    body {
      display: flex; align-items: center; justify-content: center;
    }
    #gameCanvas {
      background: linear-gradient(160deg,#cfd9f8 0,#e0d2ff 100%);
      box-shadow: 0 8px 32px #867fff66, 0 2px 12px #fff4;
      display: block;
      border-radius: 32px;
      touch-action: manipulation;
      width: 98vw; max-width: 400px;
      height: 98vh; max-height: 700px;
    }
    #coinsTextInGame {
      position: absolute;
      left: 50%; transform: translateX(-50%);
      top: 50px; z-index: 30;
      background: linear-gradient(90deg,#b07cff44 0,#ffb5d133 100%);
      border-radius: 19px;
      padding: 9px 28px; color: #483977;
      font-weight: 800; font-size: 1.32em;
      text-shadow: 0 2px 9px #fff9; letter-spacing: .08em;
      box-shadow: 0 2px 9px #b07cff13; user-select: none; pointer-events: none;
    }
    #countdownOverlay {
      display:none; position:absolute; left:0; top:0; width:100vw; height:100vh; z-index:50;
      align-items:center; justify-content:center; background:rgba(248,245,255,0.85);
      font-size:3em; color:#9857d3; font-weight:900; font-family:'Nunito',sans-serif; letter-spacing:.08em;
      text-shadow:0 2px 12px #fff;
      flex-direction: column;
    }
    @media (max-width: 500px) {
      #coinsTextInGame { font-size: 1em; padding: 6px 12px; top: 25px;}
      #gameCanvas { border-radius: 14px;}
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="coinsTextInGame">Coins: 0</div>
  <div id="countdownOverlay"></div>
  <script>
    // Logical size for the game (remains the same on all screens)
    const LOGICAL_WIDTH = 400;
    const LOGICAL_HEIGHT = 700;

    // Responsive canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resizeCanvas() {
      let scale = Math.min(window.innerWidth / LOGICAL_WIDTH, window.innerHeight / LOGICAL_HEIGHT);
      canvas.style.width = (LOGICAL_WIDTH * scale) + "px";
      canvas.style.height = (LOGICAL_HEIGHT * scale) + "px";
      const dpr = window.devicePixelRatio || 1;
      canvas.width = LOGICAL_WIDTH * dpr;
      canvas.height = LOGICAL_HEIGHT * dpr;
      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset
      ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // --- Game variables ---
    const gravity = LOGICAL_HEIGHT * 2;           // gravity in px/sec^2
    const jumpVelocity = -LOGICAL_HEIGHT * 0.75;  // jump up speed
    const bgSpeed = LOGICAL_WIDTH * 0.18;         // background speed px/sec
    const enemySpeed = LOGICAL_WIDTH * 0.36;      // enemy speed px/sec

    let player = {
      x: LOGICAL_WIDTH * 0.18,
      y: LOGICAL_HEIGHT * 0.4,
      width: 50, height: 50,
      vy: 0,
      alive: true, canJump: true, rotating: false, rotAngle: 0
    };
    let enemies = [];
    let coins = [];
    let score = 0;
    let bgX = 0;
    let slowStart = true, slowStartFrame = 0, showPlayer = false, deathFall = false, firstFlap = false;
    let ticksAfterStart = 0;
    let countdownRunning = false;

    // Images
    const kirbyImg = new window.Image();
    kirbyImg.src = "https://raw.githubusercontent.com/qnexst/404token/main/kirby.gif";
    const enemyImg = new window.Image();
    enemyImg.src = "https://i.pinimg.com/originals/4b/4f/a1/4b4fa16fff0d9782b6e53db976f89f78.gif";
    const coinImg = new window.Image();
    coinImg.src = "https://donatepay.ru/uploads/notification/images/830208_1664005822.gif";

    // UI elements
    const coinsTextInGame = document.getElementById("coinsTextInGame");
    const countdownOverlay = document.getElementById("countdownOverlay");

    // Start countdown
    function startGameWithCountdown() {
      score = 0;
      player.y = LOGICAL_HEIGHT * 0.4;
      player.vy = 0;
      player.alive = true;
      player.rotating = false;
      player.rotAngle = 0;
      enemies = [];
      coins = [];
      bgX = 0;
      deathFall = false;
      showPlayer = false;
      firstFlap = false;
      coinsTextInGame.textContent = "Coins: 0";
      coinsTextInGame.style.display = "block";
      slowStart = true;
      slowStartFrame = 0;
      ticksAfterStart = 0;
      countdownRunning = true;

      // GalaxyTon logo + countdown
      let countdown = 3;
      countdownOverlay.style.display = "flex";
      countdownOverlay.innerHTML = `
        <img src="https://galaxyton.com/assets/logo.png" alt="GalaxyTon" style="width:90px;display:block;margin-bottom:24px;">
        <div>${countdown}</div>
      `;
      let cdInt = setInterval(() => {
        countdown--;
        if (countdown === 0) {
          countdownOverlay.innerHTML = `
            <img src="https://galaxyton.com/assets/logo.png" alt="GalaxyTon" style="width:90px;display:block;margin-bottom:24px;">
            <div>GO!</div>
          `;
        } else if (countdown < 0) {
          countdownOverlay.style.display = "none";
          clearInterval(cdInt);
          showPlayer = true;
          countdownRunning = false;
        } else {
          countdownOverlay.innerHTML = `
            <img src="https://galaxyton.com/assets/logo.png" alt="GalaxyTon" style="width:90px;display:block;margin-bottom:24px;">
            <div>${countdown}</div>
          `;
        }
      }, 900);
    }
    startGameWithCountdown();

    // Controls
    window.addEventListener('keydown', (e) => {
      if ((e.code === 'Space' || e.code === 'ArrowUp') && player.alive && !countdownRunning) flap();
      if (e.code === "KeyR" && !player.alive) startGameWithCountdown();
    });
    canvas.addEventListener('mousedown', () => { if (player.alive && !countdownRunning) flap(); });
    canvas.addEventListener('touchstart', () => { if (player.alive && !countdownRunning) flap(); });

    function flap() {
      if (!player.alive) return;
      if (slowStart) { slowStart = false; player.vy = jumpVelocity; firstFlap = true; return; }
      player.vy = jumpVelocity;
    }

    // Main game loop
    let lastTime = 0;
    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      let dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;
      if (dt > 0.07) dt = 0.07;

      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    function update(dt) {
      if (countdownRunning) return;
      ticksAfterStart++;

      if (player.alive) {
        // Only player slow at start
        let gravityNow = slowStart ? gravity * 0.25 : gravity;
        player.vy += gravityNow * dt;
        player.y += player.vy * dt;

        if (player.y + player.height > LOGICAL_HEIGHT * 0.93) {
          player.y = LOGICAL_HEIGHT * 0.93 - player.height;
          player.vy = 0;
          if (!slowStart) player.alive = false, deathFall = true;
        }
        if (player.y < 0) { player.y = 0; player.vy = 0; }

        // Enemies
        if (ticksAfterStart > 60 && Math.random() < 0.02) spawnEnemy();
        enemies.forEach(e => { e.x -= enemySpeed * dt; });
        enemies = enemies.filter(e => e.x > -e.width);

        // Coins
        if (Math.random() < 0.02) spawnCoin();
        coins.forEach(c => { c.x -= bgSpeed * dt * 1.4; });
        coins = coins.filter(c => c.x > -c.size && !c.collected);

        // Collect coins
        coins.forEach(c => {
          if (!c.collected && checkCollision(player, c)) {
            c.collected = true; score++;
          }
        });

        // Check enemy collision
        enemies.forEach(e => {
          if (checkCollision(player, e)) {
            player.alive = false; deathFall = true;
          }
        });
      }
      // death fall
      if (deathFall) {
        player.rotating = true;
        player.rotAngle = 90;
        player.y += LOGICAL_HEIGHT * 0.015;
        if (player.y > LOGICAL_HEIGHT + player.height) {
          deathFall = false;
          coinsTextInGame.style.display = "none";
          setTimeout(startGameWithCountdown, 1200);
        }
      }
      // BG
      bgX -= bgSpeed * dt;
      if (bgX < -LOGICAL_WIDTH) bgX += LOGICAL_WIDTH;
      coinsTextInGame.textContent = "Coins: " + score;
    }

    function draw() {
      // BG
      ctx.clearRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);
      if (countdownRunning) {
        ctx.save();
        ctx.globalAlpha = 0.06;
        ctx.drawImage(kirbyImg, LOGICAL_WIDTH/2-120, 60, 240, 140);
        ctx.restore();
      }
      // Sky
      ctx.fillStyle = '#d2d9fa';
      ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);

      // Moving ground band
      ctx.fillStyle = "#b5aaf7";
      ctx.fillRect((bgX), LOGICAL_HEIGHT-80, LOGICAL_WIDTH, 80);
      ctx.fillRect((bgX)+LOGICAL_WIDTH, LOGICAL_HEIGHT-80, LOGICAL_WIDTH, 80);

      // Coins
      coins.forEach(c => {
        if (!c.collected) ctx.drawImage(coinImg, c.x, c.y, c.size, c.size);
      });
      // Enemies
      enemies.forEach(e => {
        ctx.drawImage(enemyImg, e.x, e.y, e.width, e.height);
      });
      // Player
      if (showPlayer && (player.alive || deathFall)) {
        ctx.save();
        ctx.translate(player.x+player.width/2, player.y+player.height/2);
        if (player.rotating) ctx.rotate(Math.PI/2);
        ctx.drawImage(kirbyImg, -player.width/2, -player.height/2, player.width, player.height);
        ctx.restore();
      }
    }

    function spawnEnemy() {
      enemies.push({
        x: LOGICAL_WIDTH + 30,
        y: Math.random()*(LOGICAL_HEIGHT*0.6)+LOGICAL_HEIGHT*0.15,
        width: 56, height: 56
      });
    }
    function spawnCoin() {
      coins.push({
        x: LOGICAL_WIDTH + 10,
        y: Math.random()*(LOGICAL_HEIGHT*0.7)+LOGICAL_HEIGHT*0.13,
        size: 32, collected: false
      });
    }
    function checkCollision(a, b) {
      let aw = a.width||a.size, ah = a.height||a.size, ax = a.x, ay = a.y;
      let bw = b.width||b.size, bh = b.height||b.size, bx = b.x, by = b.y;
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>

