<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Floppy Kirby Canvas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <link href="https://fonts.googleapis.com/css?family=Nunito:800,700,600,400|Poppins:600,400&display=swap" rel="stylesheet">
  <style>
    html, body { margin:0; padding:0; width:100vw; height:100vh; overflow:hidden; background:#ede9fa; }
    body { touch-action: none; }
    canvas { display: block; width: 100vw; height: 100vh; background: #ede9fa; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script type="module">
// ------------- Firebase setup ------------------
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
import { getDatabase, ref, get, set, update } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";
const firebaseConfig = {
  apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
  authDomain: "test-with-likes.firebaseapp.com",
  databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
  projectId: "test-with-likes",
  storageBucket: "test-with-likes.appspot.com",
  messagingSenderId: "764738820142",
  appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
  measurementId: "G-WJNF0HSN9P"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// ------------- Telegram User ------------------
const tg = window.Telegram.WebApp;
tg.expand?.();
const tgUser = tg.initDataUnsafe?.user;
if (!tgUser) {
  alert("Open the game via Telegram!");
  throw new Error("No Telegram user found");
}
const userId = tgUser.id.toString();
let username = tgUser.username || "No username";
let photo = tgUser.photo_url || "";

// ------------- Canvas & Game State ------------------
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
let W = window.innerWidth, H = window.innerHeight;
canvas.width = W; canvas.height = H;
window.addEventListener('resize', () => {
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W; canvas.height = H;
});

// -------- Game assets ---------
const avatarImg = new window.Image();
avatarImg.src = photo || "https://raw.githubusercontent.com/qnexst/404token/main/avatar.png";
const kirbyImg = new window.Image();
kirbyImg.src = "kirby.gif";
const enemyImg = new window.Image();
enemyImg.src = "https://i.pinimg.com/originals/4b/4f/a1/4b4fa16fff0d9782b6e53db976f89f78.gif";
const coinImg = new window.Image();
coinImg.src = "https://donatepay.ru/uploads/notification/images/830208_1664005822.gif";
const bgImg = new window.Image();
bgImg.src = "https://i.pinimg.com/736x/20/e9/cf/20e9cf219337614640886180cc5d1c34.jpg";

// -------- Menus ---------
let currentScreen = "loading"; // loading, menu, play, leaderboard, howtoplay, gameover
let leaderboardData = [];
let bestScore = 0;
let yourPlace = 0;

// -------- Menu Buttons ---------
const menuButtons = [
  {text: "START GAME", action: ()=>startCountdown()},
  {text: "LEADERBOARD", action: ()=>openLeaderboard()},
  {text: "HOW TO PLAY?", action: ()=>{ currentScreen = "howtoplay"; drawScreen(); }},
];

// -------- Game State ---------
let player, enemies, coins, score, isAlive, isFalling, slowStart, firstTap, scrollX, enemySpawn, coinSpawn, gameTimer;
const scrollSpeed = 3.2, gravity = 0.28, lift = -5.1, maxFall = 3.5;
const ENEMY_SPAWN_SEC = 1.4;
const COIN_SPAWN_SEC = 0.95;

// ------------- Main Loop -------------
function drawScreen() {
  ctx.clearRect(0,0,W,H);
  // Draw BG for all screens
  ctx.drawImage(bgImg, scrollX%W, 0, W, H);
  ctx.drawImage(bgImg, (scrollX%W)+W, 0, W, H);

  if(currentScreen === "loading") drawLoading();
  else if(currentScreen === "menu") drawMenu();
  else if(currentScreen === "leaderboard") drawLeaderboard();
  else if(currentScreen === "howtoplay") drawHowToPlay();
  else if(currentScreen === "play") drawGame();
  else if(currentScreen === "countdown") drawCountdown();
  else if(currentScreen === "gameover") drawGameOver();
}
function gameLoop(ts){
  scrollX -= scrollSpeed;
  drawScreen();
  if(currentScreen==="play") updateGame();
  requestAnimationFrame(gameLoop);
}

// --------- Screens Rendering -----------
function drawLoading(){
  ctx.fillStyle = "#a17cff";
  ctx.font = "900 2.3em Nunito,Arial";
  ctx.textAlign = "center";
  ctx.fillText("Loading...", W/2, H/2);
}
function drawMenu(){
  // Avatar
  ctx.save();
  ctx.beginPath();
  ctx.arc(W/2, 170, 52, 0, Math.PI*2);
  ctx.closePath();
  ctx.shadowColor = "#b8a2f9";
  ctx.shadowBlur = 14;
  ctx.drawImage(avatarImg, W/2-52, 118, 104, 104);
  ctx.restore();

  // Username
  ctx.font = "700 1.28em Nunito,Arial";
  ctx.fillStyle = "#493a66";
  ctx.textAlign = "center";
  ctx.fillText('@'+username, W/2, 245);

  // Leaderboard & Best
  ctx.font = "bold 1.1em Nunito,Arial";
  ctx.fillStyle = "#4c3380";
  ctx.fillText("Your Best: "+bestScore, W/2, 295);
  ctx.font = "600 1em Nunito,Arial";
  ctx.fillStyle = "#876cbf";
  ctx.fillText("Rank: "+yourPlace, W/2, 325);

  // Buttons
  menuButtons.forEach((btn, i) => {
    drawBtn(W/2-130, 370+i*74, 260, 54, btn.text);
  });
}
function drawBtn(x,y,w,h,text){
  ctx.save();
  ctx.shadowColor = "#ccc3ff"; ctx.shadowBlur = 12;
  ctx.fillStyle = "#ffe6fa";
  ctx.fillRect(x, y, w, h);
  ctx.shadowBlur = 0;
  ctx.strokeStyle = "#bfa1fa";
  ctx.lineWidth = 2;
  ctx.strokeRect(x, y, w, h);
  ctx.font = "bold 1.25em Nunito,Arial";
  ctx.fillStyle = "#7e47a8";
  ctx.textAlign = "center";
  ctx.fillText(text, x+w/2, y+h/2+9);
  ctx.restore();
}
function drawLeaderboard(){
  ctx.font = "900 2em Nunito";
  ctx.fillStyle = "#6d39bb";
  ctx.textAlign = "center";
  ctx.fillText("Leaderboard", W/2, 105);

  ctx.font = "700 1.15em Nunito";
  ctx.fillStyle = "#3d285b";
  ctx.fillText("Top 10", W/2, 138);

  ctx.font = "700 1.13em Nunito";
  ctx.fillStyle = "#493a66";
  leaderboardData.forEach((u,i)=>{
    if(u.id===userId) ctx.fillStyle="#d755e9";
    else ctx.fillStyle="#493a66";
    ctx.fillText(`${i+1}. @${u.username || 'User'} - ${u.highScore}`, W/2, 170+i*36);
  });

  drawBtn(34, H-80, 170, 49, "Back");
}
function drawHowToPlay(){
  ctx.font = "900 1.65em Nunito";
  ctx.fillStyle = "#9e54ed";
  ctx.textAlign = "center";
  ctx.fillText("How to Play", W/2, 120);
  ctx.font = "600 1.12em Nunito";
  ctx.fillStyle = "#533c86";
  ctx.fillText("Tap, click or press SPACE to fly up.", W/2, 170);
  ctx.fillText("Collect coins, avoid enemies!", W/2, 205);
  ctx.fillText("Try to beat your best and get in TOP 10!", W/2, 240);

  drawBtn(34, H-80, 170, 49, "Back");
}
function drawCountdown(){
  ctx.font = "900 4.3em Nunito";
  ctx.fillStyle = "#a663e5";
  ctx.textAlign = "center";
  ctx.fillText(gameTimer > 0 ? gameTimer : "GO!", W/2, H/2-20);
}
function drawGameOver(){
  ctx.font = "900 2.1em Nunito";
  ctx.fillStyle = "#ea469e";
  ctx.textAlign = "center";
  ctx.fillText("Game Over!", W/2, H/2-120);
  ctx.font = "700 1.18em Nunito";
  ctx.fillStyle = "#3d285b";
  ctx.fillText("You collected " + score + " coins", W/2, H/2-64);
  if(score > bestScore) {
    ctx.font = "700 1.18em Nunito";
    ctx.fillStyle = "#c150ff";
    ctx.fillText("NEW RECORD!", W/2, H/2-32);
  }
  drawBtn(W/2-110, H/2+30, 220, 60, "Back to Menu");
}

// ----------- Game Logic (Canvas) --------------
function startGame(){
  player = {x: W*0.22, y: H/2, vy:0, w: 56, h:56, alive:true, rot:0, show:true};
  enemies = [];
  coins = [];
  score = 0;
  isAlive = true;
  isFalling = false;
  slowStart = true;
  firstTap = false;
  enemySpawn = 0;
  coinSpawn = 0;
  scrollX = 0;
  currentScreen = "play";
}
function startCountdown(){
  gameTimer = 3;
  currentScreen = "countdown";
  let cd = setInterval(()=>{
    gameTimer--;
    if(gameTimer < 0){
      clearInterval(cd);
      startGame();
    }
    drawScreen();
  }, 930);
}
function updateGame(){
  // Spawn
  enemySpawn += 1/60;
  coinSpawn += 1/60;
  if(enemySpawn >= ENEMY_SPAWN_SEC) { addEnemy(); enemySpawn=0; }
  if(coinSpawn >= COIN_SPAWN_SEC) { addCoin(); coinSpawn=0; }
  // Move enemies
  enemies.forEach(e=>{e.x -= scrollSpeed;});
  coins.forEach(c=>{c.x -= scrollSpeed;});
  enemies = enemies.filter(e=>e.x+e.w>0);
  coins = coins.filter(c=>!c.collected && c.x+c.w>0);
  // Move player
  if(isAlive){
    if(slowStart){ player.vy+=0.07; if(player.vy>1.1) slowStart=false; }
    else player.vy+=gravity;
    if(player.vy>maxFall) player.vy=maxFall;
    player.y+=player.vy;
    if(player.y < 0) { player.y=0; player.vy=0; }
    if(player.y+player.h > H) { isAlive=false; isFalling=true; }
  } else if(isFalling){
    player.vy+=0.36; player.y+=player.vy;
    player.rot = 90;
    if(player.y > H+player.h){ isFalling=false; setTimeout(gameOver, 400);}
  }
  // Collisions
  if(isAlive){
    for(let e of enemies){
      if(collides(player,e)){ isAlive=false; isFalling=true; player.rot=90; break; }
    }
    for(let c of coins){
      if(!c.collected && collides(player,c)){ score++; c.collected=true;}
    }
  }
  // Draw game
  drawGame();
}
function drawGame(){
  // Coins
  coins.forEach(c=>{
    ctx.save();
    ctx.globalAlpha = c.collected?0.3:1;
    ctx.drawImage(coinImg, c.x, c.y, c.w, c.h);
    ctx.restore();
  });
  // Enemies
  enemies.forEach(e=>{
    ctx.save();
    ctx.drawImage(enemyImg, e.x, e.y, e.w, e.h);
    ctx.restore();
  });
  // Player
  if(player.show){
    ctx.save();
    ctx.translate(player.x+player.w/2, player.y+player.h/2);
    ctx.rotate(player.rot * Math.PI/180);
    ctx.drawImage(kirbyImg, -player.w/2, -player.h/2, player.w, player.h);
    ctx.restore();
  }
  // HUD
  ctx.font = "bold 2.2em Nunito";
  ctx.fillStyle = "#fff";
  ctx.strokeStyle = "#c286ff";
  ctx.lineWidth = 6;
  ctx.textAlign = "center";
  ctx.strokeText("Coins: "+score, W/2, 58);
  ctx.fillText("Coins: "+score, W/2, 58);
}
function addEnemy(){
  const y = Math.random()*(H-110)+20;
  enemies.push({x:W+70, y, w:70, h:70});
}
function addCoin(){
  const y = Math.random()*(H-70)+10;
  coins.push({x:W+50, y, w:44, h:44, collected:false});
}
function collides(a,b){
  return a.x<a=>x+b.w && a.x+a.w>b.x && a.y<a.y+b.h && a.y+a.h>b.y;
}
function gameOver(){
  if(score>bestScore){
    bestScore=score;
    updateScoreOnServer(score);
  }
  currentScreen = "gameover";
  getLeaderboard();
}

// --------- Firebase & LB ----------
async function updateScoreOnServer(sc){
  const userRef = ref(db, `users/${userId}`);
  await update(userRef, {
    username, photo, highScore: sc
  });
}
async function getLeaderboard(){
  const usersRef = ref(db, "users/");
  const snapshot = await get(usersRef);
  leaderboardData = [];
  yourPlace = "-";
  if(snapshot.exists()){
    let arr = Object.entries(snapshot.val()).map(([id, u])=>({
      id, username: u.username, highScore: u.highScore || 0
    }));
    arr.sort((a,b)=>b.highScore-a.highScore);
    leaderboardData = arr.slice(0,10);
    let idx = arr.findIndex(x=>x.id===userId);
    yourPlace = idx>=0 ? (idx+1) : "-";
    bestScore = arr.find(x=>x.id===userId)?.highScore || 0;
  }
  if(currentScreen==="menu"||currentScreen==="leaderboard") drawScreen();
}

// --------- Controls (on Canvas!) ----------
canvas.addEventListener("click", handleInput);
canvas.addEventListener("touchstart", handleInput);
document.addEventListener("keydown", e=>{
  if(e.code==="Space" && (currentScreen==="play"||currentScreen==="countdown")) handleInput();
});
function handleInput(evt){
  const mx = (evt.touches ? evt.touches[0].clientX : evt.offsetX);
  const my = (evt.touches ? evt.touches[0].clientY : evt.offsetY);
  if(currentScreen==="menu"){
    menuButtons.forEach((btn,i)=>{
      let bx = W/2-130, by = 370+i*74, bw=260, bh=54;
      if(mx>bx&&mx<bx+bw&&my>by&&my<by+bh) btn.action();
    });
  } else if(currentScreen==="leaderboard"||currentScreen==="howtoplay"){
    if(mx>34&&mx<204&&my>H-80&&my<H-31){
      currentScreen="menu"; drawScreen();
    }
  } else if(currentScreen==="play"){
    if(!player.alive) return;
    if(!firstTap){ firstTap=true; player.vy=lift; }
    else player.vy=lift;
  } else if(currentScreen==="gameover"){
    let bx=W/2-110, by=H/2+30, bw=220, bh=60;
    if(mx>bx&&mx<bx+bw&&my>by&&my<by+bh){
      currentScreen="menu"; drawScreen();
    }
  }
}
// --------- Initial load -----------
async function preload(){
  // Preload avatar to fix draw bug
  await new Promise(r=>{avatarImg.onload=r;});
  await getLeaderboard();
  currentScreen="menu"; drawScreen();
}
preload();
requestAnimationFrame(gameLoop);

</script>
</body>
</html>

