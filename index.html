<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Floppy Kirby ‚Äî Telegram WebApp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <link href="https://fonts.googleapis.com/css?family=Nunito:800,700,600,400|Poppins:600,400&display=swap" rel="stylesheet">
  <style>
    html, body { margin: 0; padding: 0; width: 100vw; height: 100vh; font-family: 'Nunito', 'Poppins', 'Open Sans', sans-serif; background: #f7f4ff; overflow: hidden; user-select: none;}
    #gameHudCoins {
      position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
      font-size: 2em; font-weight: 900; color: #fff;
      background: linear-gradient(90deg, #b07cff 0, #ffb5d1 100%);
      padding: 10px 32px; border-radius: 28px;
      box-shadow: 0 6px 28px #c2a4ff22;
      text-shadow: 0 2px 6px #a2d2ffb2;
      border: 2px solid #fff; pointer-events: none; z-index: 110; user-select: none;
    }
    /* –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –∫–∞–∫ —Ä–∞–Ω—å—à–µ */
    /* ... (—Å–∫–æ–ø–∏—Ä—É–π –≤—Å–µ —Å—Ç–∏–ª–∏ –∏–∑ –ø—Ä–æ—à–ª–æ–≥–æ –∫–æ–¥–∞, —Ç—É—Ç –Ω–µ –º–µ–Ω—è–ª–æ—Å—å –∫—Ä–æ–º–µ –≤—ã—à–µ) ... */
    .main-btn { margin: 14px 0; padding: 15px 36px; font-size: 1.15em; background: linear-gradient(90deg, #f7c8e0 0%, #b6eaff 100%); border: none; border-radius: 29px; box-shadow: 0 3px 16px #a2d2ff4d, 0 1px 1px #fff; cursor: pointer; font-weight: 700; color: #493a66; transition: 0.16s; display: block;}
    .main-btn:hover { background: linear-gradient(90deg, #ffc0cb 10%, #a2d2ff 100%); transform: scale(1.06);}
    .main-btn:active { transform: scale(0.96);}
    #leaderboardBackBtn, #infoBackBtn { position: absolute; top: 40px; left: 24px; padding: 11px 30px;}
    /* –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –Ω–µ –∏–∑–º–µ–Ω—è–ª–∏—Å—å */
  </style>
</head>
<body>
  <div id="mainMenu">
    <div class="menu-inner">
      <div class="tooltip">Collect coins and dodge enemies! ü™ô</div>
      <div class="user-header">
        <img id="userPhoto" src="" alt="Avatar" />
        <span id="userName">@User</span>
      </div>
      <div class="user-meta">
        <div id="yourPlace">Rank: ...</div>
        <div id="yourHighScore">Best: ...</div>
      </div>
      <div id="coinsDisplay"></div>
      <button id="startGameBtn" class="main-btn">Start Game</button>
      <button id="leaderboardBtn" class="main-btn">Leaderboard</button>
      <button id="infoBtn" class="main-btn">How to Play?</button>
    </div>
  </div>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="gameHudCoins" style="display:none;">Coins: 0</div>
    <div id="countdownOverlay"></div>
  </div>
  <div id="leaderboardContainer">
    <div class="menu-inner">
      <button id="leaderboardBackBtn" class="main-btn" style="position:absolute;">Back</button>
      <h2 style="color:#7c46a3;text-align:center;margin:8px 0 0 0">Leaderboard</h2>
      <table>
        <thead>
          <tr><th>User</th><th>Best</th></tr>
        </thead>
        <tbody id="leaderboardBody"></tbody>
      </table>
    </div>
  </div>
  <div id="infoContainer">
    <div class="menu-inner">
      <button id="infoBackBtn" class="main-btn" style="position:absolute;">Back</button>
      <h2 style="color:#7c46a3;text-align:center;margin:5px 0 10px 0;">How to Play?</h2>
      <p>
        <b>Kirby</b> flies endlessly, collecting coins and dodging enemies.<br>
        If Kirby hits an enemy or falls ‚Äî the game is over.<br>
        <b>Controls:</b> Tap / Click or Space.<br>
        The goal is to collect as many coins as possible in one run!<br>
        <br>
        Your record is saved and displayed in the leaderboard. Good luck!
      </p>
    </div>
  </div>
  <div id="gameOverPopup">
    <div class="menu-inner">
      <div class="popup-box">
        <h2>Game Over!</h2>
        <p id="gameOverText"></p>
        <button id="gameOverCloseBtn" class="main-btn">Back to Menu</button>
      </div>
    </div>
  </div>
  <script type="module">
    // Telegram WebApp
    const tg = window.Telegram.WebApp;
    if (typeof tg.requestFullscreen === 'function') tg.requestFullscreen();
    else tg.expand();
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-app.js";
    import { getDatabase, ref, get, set, update } from "https://www.gstatic.com/firebasejs/9.17.2/firebase-database.js";
    const firebaseConfig = {
      apiKey: "AIzaSyB90ev3fJRDKmn64hLTJaWjVjpHQtMjhLg",
      authDomain: "test-with-likes.firebaseapp.com",
      databaseURL: "https://test-with-likes-default-rtdb.firebaseio.com",
      projectId: "test-with-likes",
      storageBucket: "test-with-likes.appspot.com",
      messagingSenderId: "764738820142",
      appId: "1:764738820142:web:b22c6608a30e46cdcea7bf",
      measurementId: "G-WJNF0HSN9P"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    // DOM Elements
    const mainMenu = document.getElementById("mainMenu");
    const userPhoto = document.getElementById("userPhoto");
    const userName = document.getElementById("userName");
    const coinsDisplay = document.getElementById("coinsDisplay");
    const startGameBtn = document.getElementById("startGameBtn");
    const leaderboardBtn = document.getElementById("leaderboardBtn");
    const infoBtn = document.getElementById("infoBtn");
    const gameContainer = document.getElementById("gameContainer");
    const gameCanvas = document.getElementById("gameCanvas");
    const leaderboardContainer = document.getElementById("leaderboardContainer");
    const leaderboardBackBtn = document.getElementById("leaderboardBackBtn");
    const leaderboardBody = document.getElementById("leaderboardBody");
    const infoContainer = document.getElementById("infoContainer");
    const infoBackBtn = document.getElementById("infoBackBtn");
    const yourPlace = document.getElementById("yourPlace");
    const yourHighScore = document.getElementById("yourHighScore");
    const gameOverPopup = document.getElementById("gameOverPopup");
    const gameOverText = document.getElementById("gameOverText");
    const gameOverCloseBtn = document.getElementById("gameOverCloseBtn");
    const countdownOverlay = document.getElementById("countdownOverlay");
    const gameHudCoins = document.getElementById("gameHudCoins");
    // User
    let tgUser = tg.initDataUnsafe?.user;
    if (!tgUser) {
      mainMenu.innerHTML = "<h2>Please open in Telegram!</h2>";
      throw new Error("Not Telegram WebApp");
    }
    const userId = tgUser.id.toString();
    let highScore = 0;
    async function loadUser() {
      userPhoto.src = tgUser.photo_url || "https://raw.githubusercontent.com/qnexst/404token/main/avatar.png";
      userName.textContent = tgUser.username ? "@" + tgUser.username : "No username";
      const userRef = ref(db, `users/${userId}`);
      let snapshot = await get(userRef);
      if (!snapshot.exists()) {
        await set(userRef, {
          highScore: 0,
          username: tgUser.username || "",
          photo: tgUser.photo_url || ""
        });
        highScore = 0;
      } else {
        highScore = snapshot.val().highScore || 0;
      }
      coinsDisplay.textContent = `Best: ${highScore}`;
      yourHighScore.textContent = `Best: ${highScore}`;
      await updatePlace();
      mainMenu.style.display = "flex";
    }
    window.onload = loadUser;
    async function updatePlace() {
      yourPlace.textContent = "Rank: ...";
      const usersRef = ref(db, "users/");
      const snapshot = await get(usersRef);
      if (snapshot.exists()) {
        const data = snapshot.val();
        const usersArray = Object.entries(data).map(([id, u]) => ({
          id, highScore: u.highScore || 0
        }));
        usersArray.sort((a, b) => b.highScore - a.highScore);
        const place = usersArray.findIndex(x => x.id === userId) + 1;
        if (place > 0) yourPlace.textContent = `Rank: ${place} of ${usersArray.length}`;
        else yourPlace.textContent = `Rank: ‚Äî`;
      }
    }
    startGameBtn.onclick = () => { mainMenu.style.display = "none"; startGameWithCountdown(); };
    leaderboardBtn.onclick = () => { mainMenu.style.display = "none"; leaderboardContainer.style.display = "flex"; loadLeaderboard(); };
    infoBtn.onclick = () => { mainMenu.style.display = "none"; infoContainer.style.display = "flex"; };
    leaderboardBackBtn.onclick = () => { leaderboardContainer.style.display = "none"; mainMenu.style.display = "flex"; };
    infoBackBtn.onclick = () => { infoContainer.style.display = "none"; mainMenu.style.display = "flex"; };
    async function loadLeaderboard() {
      leaderboardBody.innerHTML = "";
      const usersRef = ref(db, "users/");
      const snapshot = await get(usersRef);
      if (snapshot.exists()) {
        const data = snapshot.val();
        const usersArray = Object.entries(data).map(([id, u]) => ({
          username: u.username ? `@${u.username}` : "User " + id,
          highScore: u.highScore || 0,
        }));
        usersArray.sort((a, b) => b.highScore - a.highScore);
        usersArray.forEach(user => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${user.username}</td><td>${user.highScore}</td>`;
          leaderboardBody.appendChild(tr);
        });
      }
    }
    // --- GAME CONSTANTS ---
    const FIXED_FPS = 60;
    const BASE_GRAVITY = 0.3, BASE_LIFT = -5.2, BASE_SCROLL = 1.8, BASE_MAXFALL = 3.1;
    // OBJECT GENERATION INTERVALS (real ms!)
    const ENEMY_INTERVAL_MS = 1600;  // –∫–∞–∂–¥—ã–µ 1.6 —Å–µ–∫—É–Ω–¥—ã –≤—Ä–∞–≥
    const COIN_INTERVAL_MS  = 1100;  // –∫–∞–∂–¥—ã–µ 1.1 —Å–µ–∫—É–Ω–¥—ã –º–æ–Ω–µ—Ç–∞
    let ctx, animationId, isGameRunning = false;
    let canvasWidth = 0, canvasHeight = 0;
    const player = { x: 100, y: 150, width: 45, height: 45, velocityY: 0, gravity: BASE_GRAVITY, lift: BASE_LIFT, alive: true, maxFallSpeed: BASE_MAXFALL, el: null, rotating: false, rotAngle: 0 };
    let scrollSpeed = BASE_SCROLL;
    let enemies = [], lastEnemyTime = 0;
    const enemyGif = "https://i.pinimg.com/originals/4b/4f/a1/4b4fa16fff0d9782b6e53db976f89f78.gif";
    const enemyWidth = 80, enemyHeight = 80;
    let coins = [], lastCoinTime = 0;
    const coinSize = 40, coinGifURL = "https://donatepay.ru/uploads/notification/images/830208_1664005822.gif";
    let scoreThisRun = 0, bgX = 0;
    const bgImage = new window.Image();
    bgImage.src = "https://i.pinimg.com/736x/20/e9/cf/20e9cf219337614640886180cc5d1c34.jpg";
    const collisionMargin = 10;
    let slowStart = true, showPlayer = false, deathFall = false;
    let gameStartTime = 0, lastFrameTime = 0, firstTapDone = false, ticksAfterStart = 0;
    function resizeCanvas() { canvasWidth = window.innerWidth; canvasHeight = window.innerHeight; gameCanvas.width = canvasWidth; gameCanvas.height = canvasHeight; }
    window.addEventListener("resize", () => { if (isGameRunning) resizeCanvas(); });
    function startGameWithCountdown() {
      gameContainer.style.display = "block";
      gameOverPopup.style.display = "none";
      gameHudCoins.style.display = "none";
      ctx = gameCanvas.getContext("2d");
      resizeCanvas();
      scoreThisRun = 0;
      player.y = canvasHeight / 2; player.velocityY = 0;
      player.alive = true; player.rotating = false; player.rotAngle = 0;
      enemies = []; coins = [];
      bgX = 0; deathFall = false; showPlayer = false; slowStart = true;
      gameStartTime = performance.now(); lastFrameTime = gameStartTime; firstTapDone = false;
      lastEnemyTime = 0; lastCoinTime = 0;
      if (!player.el) {
        const kirby = document.createElement("img");
        kirby.src = "kirby.gif";
        kirby.style.position = "absolute"; kirby.style.width = player.width + "px"; kirby.style.height = player.height + "px";
        kirby.style.left = player.x + "px"; kirby.style.top = player.y + "px"; kirby.style.zIndex = "900"; kirby.draggable = false;
        gameContainer.appendChild(kirby); player.el = kirby;
      } else { player.el.style.display = "none"; }
      let countdown = 3; countdownOverlay.style.display = "flex"; countdownOverlay.textContent = countdown;
      let cdInt = setInterval(() => {
        countdown--;
        if (countdown === 0) { countdownOverlay.textContent = "GO!"; }
        else if (countdown < 0) { countdownOverlay.style.display = "none"; clearInterval(cdInt); showPlayer = true; player.el.style.display = "block"; startGameCore(); }
        else { countdownOverlay.textContent = countdown; }
      }, 900);
    }
    let slowStartFrame = 0;
    function startGameCore() {
      isGameRunning = true;
      slowStart = true; slowStartFrame = 0; gameHudCoins.textContent = "Coins: 0"; gameHudCoins.style.display = "block";
      document.addEventListener("keydown", onKeyDown);
      document.addEventListener("mousedown", onClickOrTouch);
      document.addEventListener("touchstart", onClickOrTouch);
      lastFrameTime = performance.now(); ticksAfterStart = 0;
      lastEnemyTime = lastFrameTime; lastCoinTime = lastFrameTime;
      animationId = requestAnimationFrame(updateGame);
    }
    function updateGame(now = performance.now()) {
      let dt = Math.min((now - lastFrameTime) / (1000 / FIXED_FPS), 2.0);
      lastFrameTime = now;
      ctx.clearRect(0, 0, canvasWidth, canvasHeight);
      drawScrollingBackground(dt);
      if (showPlayer && player.el) player.el.style.display = "block";
      else if (player.el) player.el.style.display = "none";
      if (isGameRunning) {
        ticksAfterStart++;
        // –í—Ä–∞–≥–∏ –ø–æ—è–≤–ª—è—é—Ç—Å—è –Ω–µ —Å—Ä–∞–∑—É, –∞ —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã –ø–æ—Å–ª–µ GO
        if (now - gameStartTime > 3000 + 2000) { // 3—Å countdown + 2—Å –±–µ–∑ –≤—Ä–∞–≥–æ–≤
          if (now - lastEnemyTime >= ENEMY_INTERVAL_MS) { createEnemy(); lastEnemyTime = now; }
        }
        if (now - lastCoinTime >= COIN_INTERVAL_MS) { createCoin(); lastCoinTime = now; }
        for (let i = 0; i < enemies.length; i++) {
          const e = enemies[i]; e.x -= scrollSpeed * dt;
          e.el.style.left = e.x + "px"; e.el.style.top = e.y + "px";
          if (checkCollision(player, e)) { handleDeathAnimation(); return; }
        }
        enemies = enemies.filter(e => { if (e.x + e.width < 0) { gameContainer.removeChild(e.el); return false; } return true; });
        for (let i = 0; i < coins.length; i++) {
          const c = coins[i]; c.x -= scrollSpeed * dt;
          c.el.style.left = c.x + "px"; c.el.style.top = c.y + "px";
          if (checkCollision(player, c)) { scoreThisRun++; c.collected = true; }
        }
        coins = coins.filter(c => { if (c.collected || (c.x + c.size < 0)) { gameContainer.removeChild(c.el); return false; } return true; });
        updatePlayer(dt); gameHudCoins.textContent = "Coins: " + scoreThisRun;
        if (player.alive) { animationId = requestAnimationFrame(updateGame); }
      }
      if (deathFall) updateDeathFall(dt);
    }
    function drawScrollingBackground(dt) {
      bgX -= scrollSpeed * dt;
      if (bgX <= -canvasWidth) { bgX = 0; }
      ctx.drawImage(bgImage, bgX, 0, canvasWidth, canvasHeight);
      ctx.drawImage(bgImage, bgX + canvasWidth, 0, canvasWidth, canvasHeight);
    }
    function createEnemy() {
      const randY = Math.random() * (canvasHeight - enemyHeight - 20) + 10;
      const enemyEl = document.createElement("img");
      enemyEl.src = enemyGif; enemyEl.style.position = "absolute";
      enemyEl.style.width = enemyWidth + "px"; enemyEl.style.height = enemyHeight + "px";
      enemyEl.style.left = canvasWidth + "px"; enemyEl.style.top = randY + "px";
      enemyEl.style.zIndex = "850"; enemyEl.draggable = false; gameContainer.appendChild(enemyEl);
      enemies.push({ x: canvasWidth, y: randY, width: enemyWidth, height: enemyHeight, el: enemyEl });
    }
    function createCoin() {
      const randY = Math.random() * (canvasHeight - coinSize - 20) + 10;
      const coinEl = document.createElement("img");
      coinEl.src = coinGifURL; coinEl.style.position = "absolute";
      coinEl.style.width = coinSize + "px"; coinEl.style.height = coinSize + "px";
      coinEl.style.left = canvasWidth + "px"; coinEl.style.top = randY + "px";
      coinEl.style.zIndex = "800"; coinEl.draggable = false; gameContainer.appendChild(coinEl);
      coins.push({ x: canvasWidth, y: randY, size: coinSize, collected: false, el: coinEl });
    }
    function updatePlayer(dt) {
      let gravity = player.gravity;
      if (slowStart) {
        slowStartFrame++;
        gravity = 0.07;
        if (slowStartFrame > 72) slowStart = false;
      }
      player.velocityY += gravity * dt;
      if (player.velocityY > player.maxFallSpeed) player.velocityY = player.maxFallSpeed;
      player.y += player.velocityY * dt;
      if (player.y < 0) { player.y = 0; player.velocityY = 0; }
      if (player.y + player.height > canvasHeight) { handleDeathAnimation(); }
      player.el.style.left = player.x + "px";
      player.el.style.top = player.y + "px";
      player.el.style.transform = player.rotating ? `rotate(${player.rotAngle}deg)` : "none";
    }
    function onKeyDown(e) { if (e.code === "Space") handleFlap(); }
    function onClickOrTouch() { handleFlap(); }
    function handleFlap() {
      if (!player.alive) return;
      if (!firstTapDone) { firstTapDone = true; player.velocityY = player.lift; }
      else player.velocityY = player.lift;
      player.el.style.filter = "drop-shadow(0 0 14px #ffcbf9)";
      setTimeout(() => player.el.style.filter = "none", 120);
    }
    function checkCollision(pl, obj) {
      const pr = { x: pl.x + collisionMargin, y: pl.y + collisionMargin, width: pl.width - collisionMargin * 2, height: pl.height - collisionMargin * 2 };
      const ow = (obj.width  || obj.size) - collisionMargin * 2;
      const oh = (obj.height || obj.size) - collisionMargin * 2;
      const or = { x: obj.x + collisionMargin, y: obj.y + collisionMargin, width:  ow > 0 ? ow : 0, height: oh > 0 ? oh : 0 };
      return !(
        or.x > pr.x + pr.width ||
        or.x + or.width < pr.x ||
        or.y > pr.y + pr.height ||
        or.y + or.height < pr.y
      );
    }
    function handleDeathAnimation() {
      if (!player.alive) return;
      player.alive = false; isGameRunning = false; deathFall = true; gameHudCoins.style.display = "none";
      document.removeEventListener("keydown", onKeyDown);
      document.removeEventListener("mousedown", onClickOrTouch);
      document.removeEventListener("touchstart", onClickOrTouch);
      player.rotating = true; player.rotAngle = 90; player.velocityY = 3.5; lastFrameTime = performance.now();
      animationId = requestAnimationFrame(updateGame);
    }
    function updateDeathFall(dt) {
      player.y += player.velocityY * dt * 1.1;
      player.velocityY += 0.33 * dt;
      if (player.el) { player.el.style.top = player.y + "px"; player.el.style.transform = `rotate(90deg)`; }
      if (player.y > canvasHeight + player.height) { deathFall = false; showGameOverSequence(); }
      else { requestAnimationFrame(updateGame); }
    }
    function showGameOverSequence() {
      let newHigh = false;
      if (scoreThisRun > highScore) { highScore = scoreThisRun; newHigh = true; }
      updateScoreInDB(newHigh, scoreThisRun);
      let popupText = `You collected <b>${scoreThisRun}</b> coins this run.<br>`;
      if (newHigh) popupText += "<span style='color:#b13df3'>NEW RECORD!</span><br>";
      popupText += `Your best: <b>${highScore}</b>`;
      setTimeout(() => showGameOverPopup(popupText), 500);
    }
    function showGameOverPopup(html) { gameOverText.innerHTML = html; gameOverPopup.style.display = "flex"; }
    gameOverCloseBtn.onclick = endGameAndReturn;
    function endGameAndReturn() {
      if (isGameRunning || deathFall) {
        cancelAnimationFrame(animationId);
        document.removeEventListener("keydown", onKeyDown);
        document.removeEventListener("mousedown", onClickOrTouch);
        document.removeEventListener("touchstart", onClickOrTouch);
        isGameRunning = false; deathFall = false;
      }
      if (player.el) player.el.style.display = "none";
      for (const e of enemies) if (e.el) gameContainer.removeChild(e.el); enemies = [];
      for (const c of coins) if (c.el) gameContainer.removeChild(c.el); coins = [];
      gameContainer.style.display = "none";
      gameOverPopup.style.display = "none";
      coinsDisplay.textContent = `Best: ${highScore}`; yourHighScore.textContent = `Best: ${highScore}`;
      updatePlace();
      mainMenu.style.display = "flex";
      ticksAfterStart = 0;
    }
    async function updateScoreInDB(isNewHigh, latestScore) {
      const userRef = ref(db, `users/${userId}`);
      let updateData = {};
      if (isNewHigh) updateData.highScore = latestScore;
      await update(userRef, updateData);
      coinsDisplay.textContent = `Best: ${highScore}`; yourHighScore.textContent = `Best: ${highScore}`;
    }
  </script>
</body>
</html>
